"""
Script de execu√ß√£o e configura√ß√£o dos testes de mem√≥ria.

Este m√≥dulo configura e executa todos os testes do sistema de mem√≥ria,
fornecendo relat√≥rios detalhados e configura√ß√µes espec√≠ficas.
"""

import pytest
import sys
import os
from datetime import datetime
from pathlib import Path
import subprocess
import json
from typing import Dict, List, Any

# Adicionar o diret√≥rio src ao path para importa√ß√µes
sys.path.insert(0, str(Path(__file__).parent.parent.parent / "src"))

def setup_test_environment():
    """Configurar ambiente de teste."""
    print("üîß Configurando ambiente de teste de mem√≥ria...")
    
    # Verificar depend√™ncias
    required_packages = [
        "pytest",
        "pytest-asyncio", 
        "pandas",
        "supabase",
        "python-dotenv"
    ]
    
    missing_packages = []
    for package in required_packages:
        try:
            __import__(package.replace("-", "_"))
        except ImportError:
            missing_packages.append(package)
    
    if missing_packages:
        print(f"‚ùå Pacotes faltando: {', '.join(missing_packages)}")
        print(f"üí° Execute: pip install {' '.join(missing_packages)}")
        return False
    
    print("‚úÖ Todas as depend√™ncias est√£o dispon√≠veis")
    return True

def run_memory_tests(test_type: str = "all", verbose: bool = True) -> Dict[str, Any]:
    """
    Executar testes de mem√≥ria.
    
    Args:
        test_type: Tipo de teste ("unit", "integration", "performance", "all")
        verbose: Se deve usar output verboso
    
    Returns:
        Resultado dos testes
    """
    print(f"üß™ Executando testes de mem√≥ria: {test_type}")
    
    # Mapear tipos de teste para arquivos
    test_files = {
        "unit": ["test_memory_system.py"],
        "integration": ["test_memory_integration.py"],
        "performance": ["test_memory_performance.py"],
        "all": [
            "test_memory_system.py",
            "test_memory_integration.py", 
            "test_memory_performance.py"
        ]
    }
    
    if test_type not in test_files:
        print(f"‚ùå Tipo de teste inv√°lido: {test_type}")
        return {"success": False, "error": "Invalid test type"}
    
    # Configurar argumentos do pytest
    pytest_args = []
    
    # Adicionar arquivos de teste
    test_dir = Path(__file__).parent
    for test_file in test_files[test_type]:
        file_path = test_dir / test_file
        if file_path.exists():
            pytest_args.append(str(file_path))
    
    # Configura√ß√µes do pytest
    if verbose:
        pytest_args.extend(["-v", "-s"])
    else:
        pytest_args.append("-q")
    
    # Configurar para testes ass√≠ncronos
    pytest_args.extend([
        "--tb=short",
        "--asyncio-mode=auto"
    ])
    
    # Executar testes
    start_time = datetime.now()
    
    try:
        exit_code = pytest.main(pytest_args)
        success = exit_code == 0
    except Exception as e:
        print(f"‚ùå Erro ao executar testes: {e}")
        success = False
        exit_code = -1
    
    end_time = datetime.now()
    duration = (end_time - start_time).total_seconds()
    
    result = {
        "success": success,
        "exit_code": exit_code,
        "duration_seconds": duration,
        "start_time": start_time.isoformat(),
        "end_time": end_time.isoformat(),
        "test_type": test_type,
        "test_files": test_files[test_type]
    }
    
    if success:
        print(f"‚úÖ Testes conclu√≠dos com sucesso em {duration:.2f}s")
    else:
        print(f"‚ùå Testes falharam (c√≥digo: {exit_code}) em {duration:.2f}s")
    
    return result

def run_coverage_analysis():
    """Executar an√°lise de cobertura de c√≥digo."""
    print("üìä Executando an√°lise de cobertura...")
    
    try:
        # Verificar se pytest-cov est√° dispon√≠vel
        import pytest_cov
    except ImportError:
        print("‚ö†Ô∏è pytest-cov n√£o encontrado. Instalando...")
        subprocess.run([sys.executable, "-m", "pip", "install", "pytest-cov"])
    
    # Executar testes com cobertura
    test_dir = Path(__file__).parent
    coverage_args = [
        "--cov=src.memory",
        "--cov-report=html:tests/memory/coverage_html",
        "--cov-report=term-missing",
        str(test_dir / "test_memory_system.py"),
        str(test_dir / "test_memory_integration.py")
    ]
    
    try:
        exit_code = pytest.main(coverage_args)
        if exit_code == 0:
            print("‚úÖ An√°lise de cobertura conclu√≠da")
            print("üìÅ Relat√≥rio HTML: tests/memory/coverage_html/index.html")
        else:
            print("‚ùå Erro na an√°lise de cobertura")
        return exit_code == 0
    except Exception as e:
        print(f"‚ùå Erro ao executar cobertura: {e}")
        return False

def validate_memory_system():
    """Validar sistema de mem√≥ria completo."""
    print("üîç Validando sistema de mem√≥ria...")
    
    validations = []
    
    # 1. Verificar estrutura de arquivos
    memory_dir = Path(__file__).parent.parent.parent / "src" / "memory"
    required_files = [
        "__init__.py",
        "base_memory.py",
        "supabase_memory.py", 
        "memory_types.py",
        "memory_utils.py"
    ]
    
    for file_name in required_files:
        file_path = memory_dir / file_name
        exists = file_path.exists()
        validations.append({
            "check": f"Arquivo {file_name}",
            "status": "‚úÖ" if exists else "‚ùå",
            "passed": exists
        })
    
    # 2. Verificar migrations
    migrations_dir = Path(__file__).parent.parent.parent / "migrations"
    memory_migration = migrations_dir / "0005_agent_memory_tables.sql"
    migration_exists = memory_migration.exists()
    validations.append({
        "check": "Migration de mem√≥ria",
        "status": "‚úÖ" if migration_exists else "‚ùå",
        "passed": migration_exists
    })
    
    # 3. Verificar integra√ß√£o com agentes
    agent_dir = Path(__file__).parent.parent.parent / "src" / "agent"
    agent_files = ["base_agent.py", "orchestrator_agent.py", "csv_analysis_agent.py", "rag_agent.py"]
    
    for agent_file in agent_files:
        agent_path = agent_dir / agent_file
        if agent_path.exists():
            content = agent_path.read_text(encoding='utf-8')
            has_memory = "memory" in content.lower() or "MemoryMixin" in content
            validations.append({
                "check": f"Integra√ß√£o de mem√≥ria em {agent_file}",
                "status": "‚úÖ" if has_memory else "‚ùå", 
                "passed": has_memory
            })
        else:
            validations.append({
                "check": f"Arquivo {agent_file}",
                "status": "‚ùå",
                "passed": False
            })
    
    # 4. Verificar testes
    test_files = ["test_memory_system.py", "test_memory_integration.py", "test_memory_performance.py"]
    for test_file in test_files:
        test_path = Path(__file__).parent / test_file
        exists = test_path.exists()
        validations.append({
            "check": f"Teste {test_file}",
            "status": "‚úÖ" if exists else "‚ùå",
            "passed": exists
        })
    
    # Imprimir resultados
    print("\nüìã Resultado da Valida√ß√£o:")
    print("=" * 50)
    
    all_passed = True
    for validation in validations:
        print(f"{validation['status']} {validation['check']}")
        if not validation['passed']:
            all_passed = False
    
    print("=" * 50)
    
    if all_passed:
        print("üéâ Sistema de mem√≥ria est√° completamente implementado!")
    else:
        failed_count = sum(1 for v in validations if not v['passed'])
        print(f"‚ö†Ô∏è {failed_count} verifica√ß√µes falharam")
    
    return all_passed, validations

def generate_test_report():
    """Gerar relat√≥rio completo de testes."""
    print("üìù Gerando relat√≥rio de testes...")
    
    # Executar valida√ß√£o
    system_valid, validations = validate_memory_system()
    
    # Executar testes
    test_results = {}
    for test_type in ["unit", "integration", "performance"]:
        print(f"\n--- Executando testes {test_type} ---")
        result = run_memory_tests(test_type, verbose=False)
        test_results[test_type] = result
    
    # Criar relat√≥rio
    report = {
        "timestamp": datetime.now().isoformat(),
        "system_validation": {
            "passed": system_valid,
            "details": validations
        },
        "test_results": test_results,
        "summary": {
            "total_test_types": len(test_results),
            "passed_test_types": sum(1 for r in test_results.values() if r.get('success', False)),
            "system_complete": system_valid,
            "total_duration": sum(r.get('duration_seconds', 0) for r in test_results.values())
        }
    }
    
    # Salvar relat√≥rio
    report_file = Path(__file__).parent / f"memory_test_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
    
    try:
        with open(report_file, 'w', encoding='utf-8') as f:
            json.dump(report, f, indent=2, ensure_ascii=False)
        
        print(f"üìÑ Relat√≥rio salvo: {report_file}")
    except Exception as e:
        print(f"‚ùå Erro ao salvar relat√≥rio: {e}")
    
    # Imprimir resumo
    print("\nüìä RESUMO FINAL:")
    print("=" * 50)
    print(f"Sistema v√°lido: {'‚úÖ' if system_valid else '‚ùå'}")
    print(f"Tipos de teste executados: {report['summary']['total_test_types']}")
    print(f"Tipos de teste aprovados: {report['summary']['passed_test_types']}")
    print(f"Dura√ß√£o total: {report['summary']['total_duration']:.2f}s")
    
    if system_valid and report['summary']['passed_test_types'] == report['summary']['total_test_types']:
        print("üéâ SISTEMA DE MEM√ìRIA COMPLETAMENTE FUNCIONAL!")
    else:
        print("‚ö†Ô∏è H√° problemas que precisam ser resolvidos")
    
    return report

def main():
    """Fun√ß√£o principal."""
    print("üöÄ Iniciando valida√ß√£o completa do sistema de mem√≥ria")
    print("=" * 60)
    
    # Configurar ambiente
    if not setup_test_environment():
        print("‚ùå Falha na configura√ß√£o do ambiente")
        return False
    
    # Gerar relat√≥rio completo
    report = generate_test_report()
    
    # Executar cobertura se tudo passou
    if report['summary']['system_complete'] and report['summary']['passed_test_types'] > 0:
        print("\nüîç Executando an√°lise de cobertura...")
        run_coverage_analysis()
    
    print("\n‚ú® Valida√ß√£o conclu√≠da!")
    return True

if __name__ == "__main__":
    success = main()
    sys.exit(0 if success else 1)