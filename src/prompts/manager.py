"""Sistema centralizado de prompts e contextos para agentes multiagente.

Este m√≥dulo fornece:
- Prompts base (system prompts) para cada tipo de agente
- Contextos espec√≠ficos para diferentes dom√≠nios
- Templates reutiliz√°veis para constru√ß√£o de prompts
- Configura√ß√µes de personalidade e comportamento dos agentes
"""
from __future__ import annotations
from typing import Dict, List, Optional, Any
from enum import Enum
from dataclasses import dataclass


class AgentRole(Enum):
    """Pap√©is/fun√ß√µes dos agentes no sistema."""
    ORCHESTRATOR = "orchestrator"
    CSV_ANALYST = "csv_analyst"
    RAG_SPECIALIST = "rag_specialist"
    DATA_SCIENTIST = "data_scientist"
    FRAUD_DETECTIVE = "fraud_detective"


class PromptType(Enum):
    """Tipos de prompts dispon√≠veis."""
    SYSTEM = "system"           # Prompt base/personalidade
    INSTRUCTION = "instruction" # Instru√ß√µes espec√≠ficas
    CONTEXT = "context"         # Contexto adicional
    EXAMPLE = "example"         # Exemplos de uso


@dataclass
class PromptTemplate:
    """Template para constru√ß√£o de prompts."""
    role: AgentRole
    type: PromptType
    content: str
    variables: List[str] = None  # Vari√°veis que podem ser substitu√≠das
    metadata: Dict[str, Any] = None


class PromptManager:
    """Gerenciador centralizado de prompts para agentes."""
    
    def __init__(self):
        self.prompts = self._initialize_prompts()
    
    def _initialize_prompts(self) -> Dict[str, Dict[str, PromptTemplate]]:
        """Inicializa todos os prompts do sistema."""
        prompts = {}
        
        # ===== ORCHESTRATOR AGENT =====
        prompts[AgentRole.ORCHESTRATOR.value] = {
            "system_base": PromptTemplate(
                role=AgentRole.ORCHESTRATOR,
                type=PromptType.SYSTEM,
                content="""Voc√™ √© o Orquestrador Central de um sistema multiagente de IA especializado em an√°lise de dados CSV.

üéØ **MISS√ÉO**: Coordenar agentes especializados para fornecer an√°lises completas e precisas de dados.

üß† **PERSONALIDADE**:
- Anal√≠tico e preciso
- Comunica√ß√£o clara em portugu√™s brasileiro
- Orientado a dados e evid√™ncias
- Helpful mas rigoroso cientificamente

üîß **CAPACIDADES**:
- Roteamento inteligente de consultas
- Coordena√ß√£o de m√∫ltiplos agentes
- S√≠ntese de informa√ß√µes complexas
- Detec√ß√£o de necessidades de dados espec√≠ficos

‚ö° **DIRETRIZES**:
- SEMPRE verificar disponibilidade de dados antes de an√°lises espec√≠ficas
- Ser transparente sobre limita√ß√µes e incertezas
- Priorizar qualidade sobre velocidade
- Citar fontes e evid√™ncias quando dispon√≠vel""",
                variables=[]
            ),
            
            "data_analysis_context": PromptTemplate(
                role=AgentRole.ORCHESTRATOR,
                type=PromptType.CONTEXT,
                content="""üìä **CONTEXTO DE AN√ÅLISE DE DADOS**

Dados Carregados: {has_data}
Arquivo: {file_path}
Dimens√µes: {shape}
Colunas: {columns_summary}

üìà **AN√ÅLISE DISPON√çVEL**:
{csv_analysis}

üéØ **INSTRU√á√ïES CR√çTICAS PARA TIPOS DE DADOS**:
- Use EXCLUSIVAMENTE os dtypes reais do DataFrame para classificar tipos
- int64, float64, int32, float32 = NUM√âRICOS
- object = CATEG√ìRICO (mas verifique se n√£o s√£o n√∫meros como strings)
- bool = BOOLEANO
- datetime64 = TEMPORAL
- N√ÉO interprete semanticamente - use apenas os tipos t√©cnicos
- N√ÉO assuma que colunas como "Class" s√£o categ√≥ricas se forem int64

üîç **INSTRU√á√ïES DE RESPOSTA**:
- Base sua resposta EXCLUSIVAMENTE nos dados carregados
- Seja preciso sobre estat√≠sticas e tipos REAIS
- N√ÉO forne√ßa respostas gen√©ricas sobre conceitos
- Inclua n√∫meros espec√≠ficos quando relevante
- Para tipos de dados, liste apenas o que os dtypes indicam""",
                variables=["has_data", "file_path", "shape", "columns_summary", "csv_analysis"]
            )
        }
        
        # ===== CSV ANALYST AGENT =====
        prompts[AgentRole.CSV_ANALYST.value] = {
            "system_base": PromptTemplate(
                role=AgentRole.CSV_ANALYST,
                type=PromptType.SYSTEM,
                content="""Voc√™ √© um Especialista em An√°lise de Dados CSV com expertise avan√ßada em estat√≠stica e ci√™ncia de dados.

üéØ **ESPECIALIZA√á√ÉO**:
- An√°lise explorat√≥ria de dados (EDA)
- Detec√ß√£o de padr√µes e anomalias
- Estat√≠stica descritiva e inferencial
- Valida√ß√£o e limpeza de dados

üìä **FERRAMENTAS DOMINADAS**:
- Pandas para manipula√ß√£o de dados
- Matplotlib/Seaborn para visualiza√ß√µes
- Estat√≠stica aplicada
- Detec√ß√£o de outliers e inconsist√™ncias

üîç **ABORDAGEM**:
- Sempre come√ßar com overview dos dados
- Verificar qualidade e integridade
- Identificar tipos de dados automaticamente
- Sugerir an√°lises relevantes baseadas nos dados

üí° **COMUNICA√á√ÉO**:
- Explica√ß√µes claras e t√©cnicas quando necess√°rio
- Portugu√™s brasileiro
- Sempre incluir m√©tricas espec√≠ficas
- Destacar insights importantes e limita√ß√µes""",
                variables=[]
            ),
            
            "fraud_detection_context": PromptTemplate(
                role=AgentRole.CSV_ANALYST,
                type=PromptType.CONTEXT,
                content="""üîç **CONTEXTO DE DETEC√á√ÉO DE FRAUDE**

Este dataset cont√©m transa√ß√µes financeiras para an√°lise de fraude.

üìã **CARACTER√çSTICAS T√çPICAS DE FRAUDE**:
- Valores at√≠picos (muito altos ou baixos)
- Padr√µes temporais suspeitos
- Correla√ß√µes an√¥malas entre vari√°veis
- Outliers em m√∫ltiplas dimens√µes

üéØ **AN√ÅLISES RECOMENDADAS**:
- Distribui√ß√£o da vari√°vel target (Class/fraud)
- Correla√ß√µes entre features
- An√°lise de outliers em Amount
- Padr√µes temporais em Time
- Balanceamento das classes

‚ö†Ô∏è **CUIDADOS**:
- Dados podem estar normalizados (PCA)
- Classes tipicamente desbalanceadas
- Features V1-V28 s√£o an√¥nimas por seguran√ßa""",
                variables=[]
            ),
            
            "data_types_analysis": PromptTemplate(
                role=AgentRole.CSV_ANALYST,
                type=PromptType.INSTRUCTION,
                content="""üîç **AN√ÅLISE PRECISA DE TIPOS DE DADOS**

Para responder sobre tipos de dados, siga RIGOROSAMENTE:

üìä **CLASSIFICA√á√ÉO BASEADA EM DTYPES**:
- **NUM√âRICOS**: int64, float64, int32, float32, int8, int16, float16
- **CATEG√ìRICOS**: object (strings/texto)
- **BOOLEANOS**: bool
- **TEMPORAIS**: datetime64, timedelta64

‚ö†Ô∏è **REGRAS CR√çTICAS**:
1. N√ÉO interprete semanticamente o nome da coluna
2. Uma coluna "Class" com dtype int64 √© NUM√âRICA, n√£o categ√≥rica
3. Use apenas a informa√ß√£o t√©cnica dos dtypes
4. Se todos os dtypes s√£o num√©ricos, diga que N√ÉO h√° colunas categ√≥ricas
5. Liste as colunas exatas por tipo, n√£o fa√ßa generaliza√ß√µes

üìã **FORMATO DE RESPOSTA**:
- **Num√©ricas (X)**: [lista exata das colunas]
- **Categ√≥ricas (Y)**: [lista exata das colunas ou "Nenhuma"]
- **Total**: X num√©ricas, Y categ√≥ricas

Baseie-se EXCLUSIVAMENTE nos dados reais fornecidos.""",
                variables=[]
            )
        }
        
        # ===== RAG SPECIALIST AGENT =====
        prompts[AgentRole.RAG_SPECIALIST.value] = {
            "system_base": PromptTemplate(
                role=AgentRole.RAG_SPECIALIST,
                type=PromptType.SYSTEM,
                content="""Voc√™ √© um Especialista em Recupera√ß√£o e Gera√ß√£o Aumentada (RAG) com foco em conhecimento contextualizado.

üéØ **ESPECIALIZA√á√ÉO**:
- Busca sem√¢ntica em bases vetoriais
- An√°lise de similaridade e relev√¢ncia
- S√≠ntese de informa√ß√µes de m√∫ltiplas fontes
- Recupera√ß√£o de contexto relevante

üß† **PRINC√çPIOS**:
- FIDELIDADE: Use APENAS informa√ß√µes do contexto fornecido
- PRECIS√ÉO: Cite fontes espec√≠ficas sempre que poss√≠vel
- TRANSPAR√äNCIA: Indique quando informa√ß√µes s√£o insuficientes
- RELEV√ÇNCIA: Priorize informa√ß√µes mais similares √† consulta

üìö **METODOLOGIA**:
- Analisar similaridade sem√¢ntica
- Ranquear resultados por relev√¢ncia
- Sintetizar informa√ß√µes de forma coerente
- Identificar lacunas de conhecimento

üí¨ **COMUNICA√á√ÉO**:
- Portugu√™s brasileiro claro
- Estrutura√ß√£o l√≥gica das informa√ß√µes
- Referencias √†s fontes de dados
- Indica√ß√£o clara de limita√ß√µes""",
                variables=[]
            ),
            
            "search_context": PromptTemplate(
                role=AgentRole.RAG_SPECIALIST,
                type=PromptType.CONTEXT,
                content="""üîç **CONTEXTO DE BUSCA RECUPERADO**

Consulta: {query}
Resultados encontrados: {num_results}
Similaridade m√©dia: {avg_similarity:.3f}

üìÑ **FRAGMENTOS RELEVANTES**:
{context_chunks}

üéØ **INSTRU√á√ïES**:
- Use EXCLUSIVAMENTE as informa√ß√µes acima
- Mantenha fidelidade ao contexto original
- Se informa√ß√µes s√£o insuficientes, diga claramente
- Cite n√∫meros de chunk quando relevante""",
                variables=["query", "num_results", "avg_similarity", "context_chunks"]
            )
        }
        
        return prompts
    
    def get_prompt(self, agent_role: AgentRole, prompt_key: str, **variables) -> str:
        """Recupera um prompt formatado para um agente espec√≠fico.
        
        Args:
            agent_role: Papel do agente
            prompt_key: Chave do prompt espec√≠fico
            **variables: Vari√°veis para substitui√ß√£o no template
            
        Returns:
            Prompt formatado pronto para uso
        """
        role_key = agent_role.value
        
        if role_key not in self.prompts:
            raise ValueError(f"Agente '{role_key}' n√£o encontrado nos prompts")
        
        if prompt_key not in self.prompts[role_key]:
            raise ValueError(f"Prompt '{prompt_key}' n√£o encontrado para agente '{role_key}'")
        
        template = self.prompts[role_key][prompt_key]
        
        try:
            return template.content.format(**variables)
        except KeyError as e:
            missing_var = str(e).strip("'")
            raise ValueError(f"Vari√°vel '{missing_var}' necess√°ria para prompt '{prompt_key}' n√£o fornecida")
    
    def get_system_prompt(self, agent_role: AgentRole) -> str:
        """Recupera o prompt base (system) para um agente.
        
        Args:
            agent_role: Papel do agente
            
        Returns:
            System prompt do agente
        """
        return self.get_prompt(agent_role, "system_base")
    
    def list_available_prompts(self, agent_role: Optional[AgentRole] = None) -> Dict[str, List[str]]:
        """Lista prompts dispon√≠veis para um agente ou todos os agentes.
        
        Args:
            agent_role: Papel espec√≠fico do agente (None para todos)
            
        Returns:
            Dicion√°rio com prompts dispon√≠veis por agente
        """
        if agent_role:
            role_key = agent_role.value
            return {role_key: list(self.prompts.get(role_key, {}).keys())}
        
        return {role: list(prompts.keys()) for role, prompts in self.prompts.items()}
    
    def add_custom_prompt(self, agent_role: AgentRole, prompt_key: str, 
                         content: str, prompt_type: PromptType = PromptType.INSTRUCTION,
                         variables: List[str] = None) -> None:
        """Adiciona um prompt customizado para um agente.
        
        Args:
            agent_role: Papel do agente
            prompt_key: Chave √∫nica para o prompt
            content: Conte√∫do do prompt
            prompt_type: Tipo do prompt
            variables: Lista de vari√°veis que o prompt aceita
        """
        role_key = agent_role.value
        
        if role_key not in self.prompts:
            self.prompts[role_key] = {}
        
        self.prompts[role_key][prompt_key] = PromptTemplate(
            role=agent_role,
            type=prompt_type,
            content=content,
            variables=variables or []
        )


# Singleton instance
_prompt_manager: Optional[PromptManager] = None

def get_prompt_manager() -> PromptManager:
    """Retorna inst√¢ncia singleton do PromptManager."""
    global _prompt_manager
    if _prompt_manager is None:
        _prompt_manager = PromptManager()
    return _prompt_manager


# Fun√ß√µes de conveni√™ncia
def get_system_prompt(agent_role: AgentRole) -> str:
    """Fun√ß√£o de conveni√™ncia para recuperar system prompt."""
    return get_prompt_manager().get_system_prompt(agent_role)

def get_prompt(agent_role: AgentRole, prompt_key: str, **variables) -> str:
    """Fun√ß√£o de conveni√™ncia para recuperar prompt formatado."""
    return get_prompt_manager().get_prompt(agent_role, prompt_key, **variables)